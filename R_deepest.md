## R deepest
本章将会介绍我对deepr中的最后几章的阅读感想，主要以概念为主，同时我会结合其他的资料进行理解。

### 环境（environment）

在R语言中，环境（environment）是一个重要的数据结构，它用来存储变量的名称和它们对应的值。环境可以被看作是一个包含一系列键值对的集合，其中键是变量名，值是变量对应的数据或对象。

#### 环境的基本概念  
**层级结构**：环境在R中具有层级结构。每个环境都有一个父环境（`parent environment`），如果在当前环境中找不到某个变量，它会继续向上查找，直到全局环境（`.GlobalEnv`）或空环境（`emptyenv()`）为止。这种层级结构使得变量查找和作用域管理非常灵活。

**全局环境**：当你在R控制台中定义一个变量时，它默认存储在**全局环境**中。全局环境是用户工作空间的环境，也就是你可以直接访问和修改的环境。

**局部环境**：在函数调用时，会创建一个新的环境，这个环境称为局部环境（`local environment`）。局部环境会存储函数内部定义的变量，并在函数结束后销毁，除非它被显式返回或绑定到其他对象。

**包环境**：每个加载的R包都有自己的环境，用来存储包中定义的函数和数据对象。这些环境在搜索路径中位于全局环境之上。

**空环境**：emptyenv()是所有环境的最终父环境，它不包含任何对象，也不能被修改。  

<br>


#### 环境的基本操作
```R
#创建环境
my_env <- new.env()

#访问和修改环境变量
my_env$a <- 10  # 添加变量a
assign("b", 20, envir = my_env)  # 添加变量b
print(my_env$a)  

#获取环境内的所有变量
ls(envir = my_env)

#删除环境的变量
rm(a, envir = my_env)
```

<br>

#### 环境与变量
在R语言中，当你将一个变量赋值给另一个变量时，R会复制这个变量的值，并且这两个变量之间不会有直接的联系。这意味着如果你改变了第一个变量的值，第二个变量的值不会受到影响。比如下面这个例子，`b <- a`只是创建了一个相同的副本，`a`和`b`都指向相同的对象`10`，而`a <- 20`只是修改了`a`所指向的对象，对`b`没有任何影响。
```R
a <- 10
b <- a
a <- 20
print(b)
## b = 10
```
<br>

在R语言中，你可以通过引用环境中的对象来访问和修改变量。环境（environment）在R中是一个用来存储对象（例如变量、函数等）的数据结构。每个环境都有一个父环境，并且这些环境形成一个链条，可以从当前环境一直追溯到全局环境或空环境。

<br>

#### 查看环境与环境中求值
```R
#查看当前环境
environment()
<environment: R_GlobalEnv>

#也可以这样
> sys.frame(sys.nframe())
<environment: R_GlobalEnv>
```
<br>

`quote()`函数用于将表达式转换为语言对象而不对其进行求值。换句话说，它可以“捕获”表达式，而不会立即计算其结果。通常用于保存表达式以便稍后执行或分析。

`eval()`函数用于在指定环境中对一个表达式进行求值。它的第一个参数是需要求值的表达式，第二个可选参数是环境。如果没有指定环境，eval()会在当前环境中进行求值。
```R
a <- 10
b <- 20

expr <- quote(a+b) #将a+b转化为对象但不求值
result <- eval(expr) #延迟求值
print(result)
[1] 30
```
<br>

在R语言中，get函数用于根据对象的名称（以字符串形式）来检索对象的值。这个函数在处理动态生成的变量名或在运行时访问对象时非常有用。`get`函数可以从一个特定环境中抽取特定的变量：
```R
e1 <- new.env()
> assign("var", 100, envir = e1)
> value <- get("var", envir = e1)  #从e1环境中获取变量var
> print(value)
[1] 100
```
<br>

#### 环境的继承
每个环境都有一个指向父环境的指针，除了顶层的全局环境（Global Environment）或命名空间环境（Namespace Environment），它们的父环境是 `NULL` 或者 `baseenv()`。当你在某个环境中查找变量时，R 会首先在当前环境中查找，如果找不到，就会顺着父环境链向上查找，直到找到该变量或到达顶层环境。  

环境继承允许在不同的环境之间**共享变量**。例如，当你在一个函数内调用另一个函数时，子函数会继承父函数的环境，因此可以访问父函数中的变量。如果变量在当前环境中没有定义，R 会沿着继承链向上查找，直到在某个父环境中找到该变量。 
```R
e1 <- new.env()

#对e1内的x变量赋值
> e1$x <- 20
> e1$x
[1] 20

> e2 <- new.env(parent = e1)
> e2$x  
NULL

> get("x", envir = e1)
[1] 20  

get("x", envir = e2)
[1] 20  ##e2继承了父环境e1的变量x
```
<br>

书上讲了一个这个例子，形象地描绘了环境之间的关系：
```R
e2 <- as.environment(list(x="spam")) # to recall

eval(expr_comp, envir=e2)

## Error in x < "eggs": could not find function "<"
```
这里创建了一个包含了`x`变量的一个e2环境，但是在这个环境里并没有定义`<`这个关系，而这个关系一般都是在`base`环境中定义的，所以可以这样做：
```R
e2 <- as.environment(list(x="spam"))
parent.env(e2) <- base #将e2的父环境设置为base，即e2继承了base的环境
eval(expr_comp, envir=e2)
```

<br>

#### 环境的一些小函数
`ls`函数用于列出当前环境的所有对象（变量、函数），可以通过指定 envir 参数来列出特定环境中的对象。
```R
ls()  # 列出当前环境中的对象
ls(envir = .GlobalEnv)  # 列出全局环境中的对象
ls(envir = sys.frame(1))  # 列出当前调用栈中第1层函数帧中的对象
```

<br>
  

`sys.frame`返回指定的函数调用帧中的环境
```R
sys.frame(0)  # 返回当前执行的帧的环境
sys.frame(1)  # 返回上一级函数调用的环境
sys.frame(sys.nframe())  # 返回最顶层调用帧的环境
```

<br>

`sys.nframe`返回当前函数调用栈中的帧（frame）数量，也就是调用深度。这个函数通常用于确定当前代码运行到哪一层的调用栈，从而了解代码的执行深度或用于调试。
```R
sys.nframe()  # 获取当前调用栈的深度
```

<br>

补充概念：**函数的调用栈**  
1. 函数的调用栈`（Call Stack）`是计算机程序在执行过程中用来管理函数调用和返回的一个数据结构。它跟踪了程序在执行期间的函数调用的顺序和状态。调用栈的基本原理如下：

2. 函数调用：当程序执行到一个函数调用时，程序会将该函数的执行上下文（包括局部变量、返回地址等）压入调用栈中。

3. 函数执行：在函数执行过程中，调用栈会保持该函数的状态。当函数调用另一个函数时，新的函数上下文会被压入调用栈中。

4. 函数返回：当一个函数执行完毕后，程序会从调用栈中弹出该函数的上下文，并返回到上一个函数的位置继续执行。

5. 栈帧：每个函数调用对应一个栈帧`（Stack Frame）`，其中包含了函数的局部变量、参数、返回地址等信息。

6. 栈溢出：如果调用栈的空间用尽（通常是由于无限递归或过深的函数调用），就会发生栈溢出错误`（Stack Overflow）`，程序可能会崩溃。

<br>

R 维护了一个完整的帧栈（frame stack）。全局环境被分配为 0。每次调用一个函数时，栈会增加一个帧，而从函数返回时，栈会减少一个帧。要获取当前的帧号，可以调用 `sys.nframe`。这就是为什么 `sys.frame(sys.nframe())` 返回当前环境的原因。

<br>

### 包（package）
#### 包中的对象
在 R 语言中，包（package）管理了函数和数据等对象。每个包有两个主要的环境：

`namespace:pkg`：这是包内部的命名空间。所有包中的对象（例如函数和数据结构）都在这个命名空间中定义。这个环境包含了包内所有闭包（即定义在包内部的函数）的封闭环境。简单来说，`namespace:pkg` 是包的内部工作环境，封装了包内所有的定义。

`package:pkg`：这是用户访问包中对象的界面。它包含了从` namespace:pkg` 中导出的对象，也就是说，用户可以直接访问并使用这些对象。通过将包附加到搜索路径中（例如使用 `library(pkg)` 或 `require(pkg)`），用户可以使用 `package:pkg `中的函数和数据。这个环境是用户与包交互的主要方式。

总的来说，`namespace:pkg`是包的内部环境，而`package:pkg`是包的外部接口，用户可以通过这个接口使用包中已定义的对象。

<br>

#### 加载包的函数
通常而言，可以通过`library()`或者`require()`来加载包，但是这两个函数之间有很大的区别： 

1. 如果指定的包不可用或未安装，`library() `会抛出一个错误并停止执行。它的主要作用是加载和附加包到搜索路径中。
2. 如果指定的包不可用或未安装，`require() `会返回 `FALSE` 并不会中断执行。这使得 `require()` 更适合在**函数**中使用，以便在包不可用时执行其他备用代码。

<br>

#### 包的一些信息
以`rpackagedemo`为例：  
![alt text](bc74c5541b45be784df6cff313c6277.png)

其中：  
`Imports `字段：列出包所依赖的其他包，但这些包不会被附加到搜索路径中。它们只是供当前包内部使用，不会影响用户的环境。

`Depends `字段：列出包所依赖的其他包，并且这些包会被附加到搜索路径中。这意味着包中的函数和数据可以直接在用户的环境中使用。

<br>

### 练习与解答
1. 框架（frame）在环境中的作用是什么？

框架（frame）在 R 环境中表示一个环境中的绑定（即变量和值的映射）。每个函数调用都会创建一个新的框架，这个框架包含函数的局部变量和其他必要的信息。框架帮助管理函数调用的上下文。

2. 封闭环境（enclosing environment）的作用是什么？如何读取或设置它？

封闭环境（enclosing environment）是一个环境，它包裹了当前环境，提供了对外部变量的访问。可以通过 parent.frame() 或 sys.parent() 函数读取当前环境的封闭环境。封闭环境通常在函数定义时自动设置，不能直接修改，但可以通过 parent.env() 函数设置或查询特定的封闭环境。

3. 命名列表（named list）和环境（environment）之间有什么区别？

命名列表是一个包含名称和对应值的对象，通常用于存储数据。环境是一个特殊的对象，用于存储变量的绑定，并且支持环境查找机制。环境可以具有封闭环境，而命名列表不支持封闭环境和函数的上下文。

4. 哪些函数和操作符作用于命名列表，但不能应用于环境？

比如 `[[、$、names() `等函数和操作符用于访问和修改命名列表的元素，但不能直接用于环境。环境的访问和操作通常使用 get()、assign() 和其他环境专用的函数。

5. 为什么说环境在传递给 R 函数时不是按值传递？

环境是按引用传递的，这意味着传递给函数的是对环境的引用，而不是环境的副本。这样，函数内部对环境的修改会影响到原始环境。

6. 我们说对象有时会按需复制（copy-on-demand）是什么意思？

按需复制意味着当对一个对象的修改请求发生时，R 会创建该对象的副本。这种机制减少了不必要的复制，提高了效率，尤其是在函数调用和环境操作中。

7. 如果在要评估的表达式中列出的名称在当前环境中未找到，会发生什么？

如果表达式中列出的名称在当前环境中未找到，R 会在封闭环境中查找该名称，直到找到或没有更多的环境可供查找。如果名称在所有可用环境中都未找到，则会抛出错误。

8. 我们如何以及附加什么样的对象到搜索路径中？

可以通过 library() 或 require() 函数将包附加到搜索路径中。这使得包中的函数和数据对用户可用。通常，这包括 R 包和命名空间。

9. 如果搜索路径中有两个相同的对象名，会发生什么？

如果搜索路径中有两个相同的对象名，R 会按照搜索路径的顺序使用第一个找到的对象。较早附加的对象会覆盖后面附加的相同名称的对象。

10. 当我们说包的命名空间在加载时是锁定的，是什么意思？

当包的命名空间被加载时，它是锁定的，这意味着无法修改包的对象和环境。这是为了确保包的稳定性和一致性，防止用户在运行时意外更改包的内部结构。

11. 在控制台上评估表达式时，当前环境是什么？

在控制台上评估表达式时，当前环境通常是全局环境。也就是说，任何在控制台上输入的代码都在全局环境中执行。

12. <- 和 <<- 之间有什么区别？

<- 是用于在当前环境中赋值的操作符。<<- 用于在当前环境及其封闭环境中进行赋值，如果在当前环境中找不到变量，它会向上查找并在封闭环境中赋值。

13. 包有自己的搜索路径吗？

是的，包在加载时会创建自己的命名空间，但包本身不具有独立的搜索路径。搜索路径是用于查找函数和对象的机制，包的对象会被附加到全局搜索路径中。

14. 什么是函数闭包（function closure）？

函数闭包是一个函数及其相关的环境的组合。闭包捕获了创建它的环境，使得即使函数在外部作用域中被调用，它仍然可以访问创建它时的环境中的变量。

15. 动态作用域和词法作用域（lexical scope）有什么区别？

动态作用域是指函数调用时，环境是根据调用栈的上下文决定的。词法作用域是指函数的作用域在函数定义时就确定了，与调用时的上下文无关。R 主要使用词法作用域。

16. 在评估函数时，当前（局部）环境的封闭环境是如何确定的？它是否与调用环境相同？如何程序matically 获取它们？

当前（局部）环境的封闭环境是在函数定义时确定的，通常是函数定义时的外部环境。它与调用环境不完全相同。可以通过 parent.frame() 和 sys.parent() 等函数获取当前环境的封闭环境。

17. 函数工厂（function factories）是如何工作的？

函数工厂是创建其他函数的函数。它们通过在内部定义和返回一个新函数来工作，这个新函数通常会捕获工厂函数的环境，用于定制函数的行为。

18. package:pkg 和 namespace:pkg 环境有什么区别？

package:pkg 环境是用户可以直接访问的环境，包含从 namespace:pkg 中导出的对象。namespace:pkg 是包的内部环境，包含所有的定义和闭包，但不直接暴露给用户。

<br>

### 惰性计算（lazy evaluation）
#### 惰性符号
什么叫lazy evaluation？  
非严格、不急切、延迟的计算。这种特性意味着函数参数不会立即被计算，而是等到真正需要使用它们时才进行计算。

在先前的章节我有提到，像`if`、`&&`和`||`都属于lazy符号，他们首先会计算第一个位置，如果已经能判断出来了，说明没有必要进行后面的比较运算，直接返回结果。  

在 R 中，函数参数的求值是延迟的，直到第一次真正需要使用该参数的值时才会进行计算。如果从未使用到参数的值，那么它的求值可以被无限期推迟。一旦参数被求值，其结果会被缓存，因此即使再次使用该参数，也不会重新计算。

#### 延迟函数
`substitute()` 函数是 R 中的一个重要工具，用于捕获和处理未计算的表达式。它返回表达式的“符号”表示，而不是实际的值。这在元编程和延迟计算中非常有用，因为它允许我们操作和查看表达式的结构。而`eval()`函数会返回表达式的值。
```R
y <- 10
> expr <- substitute(x + y, list(x=5))
> print(expr)
5 + y

> eval(expr)
[1] 15
```
<br>

`quote() `是 R 中的一个函数，用于捕获表达式而不进行评估。它与 substitute() 有些类似，但更为简单。`quote()` 返回一个表达式对象，可以在之后的代码中进行处理、分析或评估。


<br>

#### 转换函数
`deparse() `是 R 中的一个函数，用于将 R 对象（通常是表达式、函数或语言对象）转换为其对应的字符向量表示形式。换句话说，`deparse() `将表达式或函数转换为 R 代码的字符形式，这样就可以以字符串的形式查看或操作这些代码。`deparse() `经常与` substitute()` 结合使用，以获取函数参数的原始表达式并将其转换为字符表示。例如：
```R
my_function <- function(x) {
  expr <- substitute(x)
  deparsed_expr <- deparse(expr)
  print(deparsed_expr)
}
my_function(a + b)
[1] "a + b"
```

<br>

#### 曲线（curve）
`curve() `是 R 中用于绘制函数曲线的一个便捷函数。它可以在指定的区间内绘制数学函数的图形。该函数适用于快速可视化函数的形状和行为。基本语法如下：
```R
curve(expr, from = NULL, to = NULL, n = 101, add = FALSE, type = "l", ...)

expr：表示要绘制的函数。可以是一个公式或函数
from：曲线绘制的起点（x 轴的起始值）
to：曲线绘制的终点（x 轴的结束值）
n：曲线上的点数（决定了曲线的平滑程度，默认 101 个点）
add：如果为 TRUE，则将曲线添加到现有图形上，而不是新建图形
type：指定图形类型，默认为线型 "l"，也可以为 "p"（点）等
...：其他传递给 plot() 的图形参数，如颜色、线宽等

```
比如：
```R    
curve(sin(1/x^2), 1/pi, 3, 1000)
```
如图所示：
![alt text](image.png)

<br>

#### 数据框变量的引用与修改
`with()` 函数用于在给定数据框或环境中执行表达式，而不需要反复引用数据框的名字。它在数据框中评估表达式，并返回表达式的结果。该函数只引用数据框并执行表达式，不会对原数据框修改。
```R
#语法
with(data, expr)

#示例
with(iris, mean(Sepal.Length))
[1] 5.843333
```

`within()` 函数用于修改数据框或列表，并返回修改后的数据框。它允许在一个临时环境中进行操作，而这些操作的结果会更新到原始数据框或列表中。
```R
#语法
within(data, expr)

#示例
within(iris, Sepal.Length <- log(Sepal.Length))
 head(iris)
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa
4          4.6         3.1          1.5         0.2  setosa
5          5.0         3.6          1.4         0.2  setosa
6          5.4         3.9          1.7         0.4  setosa
```
<br>

#### 管道运算符
管道运算符 `%>%` 的作用是将左侧表达式的结果作为右侧函数的第一个参数传递。它避免了嵌套函数调用，使代码更容易阅读和维护。
```R
#基本语法
object %>% function1() %>% function2() %>% function3()

#示例
library(dplyr)

df <- data.frame(
  x = 1:10,
  y = 11:20
)

# 使用管道运算符对数据进行操作
result <- df %>%
  filter(x > 5) %>%       # 筛选 x > 5 的行
  mutate(z = x + y) %>%   # 创建新列 z = x + y
  summarise(mean_z = mean(z))  # 计算 z 的平均值

print(result)
```

<br>

#### 公式（formula）
从语言的角度来看，公式实际上是对 `~`运算符的未评估调用。创建公式时，甚至不需要显式地使用 `quote() `函数。换句话说，当在 R 中使用公式时，R 会自动将公式视为表达式并进行适当处理。
```R
formula <- y ~ x + z
```
在这个例子中，`y ~ x + z `是一个公式对象，表示 `y` 是因变量，`x` 和 `z` 是自变量。R 解释这段代码时，将其视为 `y` 和 `x + z `之间的关系。公式本质上是对` ~ `运算符的未评估调用，而 `~ `本身在这个上下文中被用作连接因变量和自变量的符号。公式广泛运用到回归模型中。




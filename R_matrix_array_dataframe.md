## 进阶数据结构（数组与矩阵、数据框）

### 一、 矩阵与数组
二维数组由行列两个维度的向量组成，一般使用`array()`构建，而特殊的二维数组叫做矩阵，使用`matrix()`构建。

<mark>构建矩阵的方法：
```R
#法一：
a <- matrix(1:6,byrow = TRUE, nrow = 3)
> a
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6

#法二：
 array(1:6,dim = c(2,3)) #dim为数组的维度
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
```
在这里，我设定了矩阵的行数为3行，且`byrow = TRUE`为按行填充（优先填充于行，一行填满了再开启下一行）。在这里，`dim`为数组的维度，二维为矩阵，以此类推。

同时，可以使用`dimnames`参数给矩阵的行和列赋予名字：
```R
 a <- matrix(1:6,byrow = TRUE, nrow = 3, dimnames = list(c("a","b","c"),c("d","e")))
> a

  d e
a 1 2
b 3 4
c 5 6
```

<mark>矩阵的行与列操作

在R中，矩阵默认是按列填充的，一般也是对列进行操作，比如`as.matrix(1:2)`返回的是一个列向量，而`t(1:2)`返回的是一个行向量；  
具体而言，对于矩阵的行列操作，`rbind()`表示对矩阵的行进行合并，即合并后的行数增加，列数不变；`cbind()`表示对矩阵的列进行合并，即合并后的列数增加，行数不变：
```R
#行合并
rbind(1:3,4:6,7:9)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9

#列合并
 cbind(1:3,4:6,7:9)
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9
```

`simplify2array` 是 R 语言中的一个函数，用于将列表或向量简化为数组或矩阵。这个函数会尝试将列表中的元素组合成一个数组，如果这些元素具有相同的长度且类型一致，那么就可以成功地简化：
```R
a = list(c(1,2,3),c(4,5,6),c(7,8,9))
> simplify2array(a)  ##返回一个矩阵
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9

##也可以用do.call函数：
do.call(cbind,list(a = 1, b = c(2,3), c = c(4,5,6)))
     a b c
[1,] 1 2 4
[2,] 1 3 5
[3,] 1 2 6
Warning message:
In (function (..., deparse.level = 1)  :
  number of rows of result is not a multiple of vector length (arg 2)
```

还可以：
```R
a <- list(runif(15),rnorm(10))
sapply2 <- function(...){
+ do.call(cbind,lapply(...))
+ }
> sapply2(a,mean)
          [,1]         [,2]
[1,] 0.4939233 -0.001564338
```

<br>

矩阵的元素可以不是数值型，也可以是字符型和逻辑值：
```R
matrix(strrep(LETTERS[1:6],1:6),nrow = 2)
     [,1] [,2]   [,3]
[1,] "A"  "CCC"  "EEEEE"
[2,] "BB" "DDDD" "FFFFFF"
```
<br>

<mark>矩阵/二维数组的属性

矩阵或二维数组的属性一般是行和列的数目与名称，比如：
```R
 A <- matrix(1:6,nrow = 3, dimnames = list(LETTERS[1:3],LETTERS[4:5]))

> A
  D E
A 1 4
B 2 5
C 3 6

> dim(A)  #同attr(A,"dim")
[1] 3 2

> dimnames(A)  #同attr(A,"dimnames")
[[1]]
[1] "A" "B" "C"

[[2]]
[1] "D" "E"

#更改填充方式，与A的转置不同
'dim<-' (A,c(2,3))
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
```

<br>

<mark>数组索引

与python相似，R中的索引采用`[]`的形式，举个例子：
```R
A <- matrix(1:12,byrow = TRUE, nrow = 3)
> A
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    4
[2,]    5    6    7    8
[3,]    9   10   11   12

##这里索引的顺序是以列为准的
> A[6]
[1] 10

##也可以采用[row,col]的形式
> A[3,2]
[1] 10

##修改列名
B <- 'dimnames<-'(A,list(LETTERS[1:3],LETTERS[4:7]))
> B
  D  E  F  G
A 1  2  3  4
B 5  6  7  8
C 9 10 11 12
```

矩阵和二维数组的索引的方法如下所示：
```R
 A[1]
[1] 1  #以列的顺序为准的第一个元素

> A[1,]
[1] 1 2 3 4  #第一行的全部元素

> A[,1]
[1] 1 5 9  #第一列的全部元素
```
<br>


其中，如果不想失去数组或矩阵原始的维度，可以加入`drop = FALSE`参数，此参数默认为`TRUE`：
```R
A[1,,drop = FALSE]

     [,1] [,2] [,3] [,4]
[1,]    1    2    3    4  #结果为第一行，且保留一行四列的属性
```

<br>

<mark>矩阵截取的规则

在R中，我们可以截取矩阵的任意行与列，返回一个新的矩阵：
```R
A <- matrix(1:12,nrow = 3, dimnames = list(LETTERS[1:3],LETTERS[4:7]))
> A
  D E F  G
A 1 4 7 10
B 2 5 8 11
C 3 6 9 12

##截取第一、二行和第一至三列
> A[1:2,c(1:3)]
  D E F
A 1 4 7
B 2 5 8

##不选择第一行，且选取D、F列
A[-1,c("D","F")]
  D F
B 2 8
C 3 9
```
<br>

<mark>基于逻辑值的索引

R中支持矩阵中索引为逻辑值，从而对原矩阵进行截取：
```R
##选取第一行与第三行和二到四列的元素
 A[c(TRUE,FALSE,TRUE),2:4]
  E F  G
A 4 7 10
C 6 9 12

##求每行和每列元素的平均值
colMeans(A)
 D  E  F  G
 2  5  8 11

rowMeans(A)
  A   B   C
5.5 6.5 7.5

##索引值可以为筛选条件
A[2,colMeans(A)>2]  #选择第二行与均值大于2的列
 E  F  G
 5  8 11

##逻辑值索引
 A>8
      D     E     F    G   ##返回布尔值
A FALSE FALSE FALSE TRUE
B FALSE FALSE FALSE TRUE
C FALSE FALSE  TRUE TRUE

> A[A>8]   #返回A中大于8的元素
[1]  9 10 11 12
 ```

同时，也可以使用一个两列的矩阵或数组对某矩阵进行索引:
```R
I <- cbind(c(1,2,3),c(2,4,1))
> I
     [,1] [,2]  #可以对（1，2），（2，4），（3，1）的位置元素进行引用
[1,]    1    2
[2,]    2    4
[3,]    3    1

> A[I]
[1]  4 11  3  
```

<br>

<mark>矩阵的常用操作

1. 矩阵的转置(transpose)  
   矩阵的转置一般使用`t()`函数进行操作:
```R
 A <- matrix(1:6,nrow = 3)
> A
     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6
> t(A)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
```

2. 矩阵元素的处理  
   可以使用`round`,`sqrt`,`log`等数学函数对矩阵的所有元素进行整体处理：
```R
 round(sin(A),2)
     [,1]  [,2]
[1,] 0.84 -0.76
[2,] 0.91 -0.96
[3,] 0.14 -0.28
```

3. 对行或列进行操作  
   `apply(matrix,n,f)`是对矩阵的行或列（n=1或2维度）进行f函数的操作：
```R
 apply(A,1,mean) #返回A每一行的均值，同rowMeans(A)
[1] 2.5 3.5 4.5

 apply(A,2,mean) #返回A每一列的均值，同colMeans(A)
[1] 2 5
```

4. 矩阵的运算
   对于两个行数与列数相同的矩阵，可以使用对两个矩阵中的相同位置元素进行运算：
```R
A <- rbind(1:3,4:6)
> A
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
> B <- matrix(c(2,4,9,12,6,24),byrow = TRUE, nrow = 2)
> B
     [,1] [,2] [,3]
[1,]    2    4    9
[2,]   12    6   24
> A+B
     [,1] [,2] [,3]
[1,]    3    6   12
[2,]   16   11   30
> A*B
     [,1] [,2] [,3]
[1,]    2    8   27
[2,]   48   30  144
```

练习：对一个矩阵的每一列的元素进行归一化处理
```R
 standardise <- function(A,...){
+ result <- apply(A,2,function(x){
+ (x-mean(x))/sd(x)})
+ return(result)
+ }

> standardise(A)
           [,1]       [,2]       [,3]
[1,] -0.7071068 -0.7071068 -0.7071068
[2,]  0.7071068  0.7071068  0.7071068
```

5. 矩阵的乘法（线性代数回顾）  
   一般，使用`*`对两个同行同列的矩阵的相同位置的元素进行相乘处理，而`%*%`对两个矩阵进行矩阵乘法运算，前提是前一个矩阵的列数要和后一个矩阵的行数相同：
```R
A <- rbind(c(1,2,3),c(4,5,6))
> A
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6

> B <- matrix(2:7,nrow = 3)
> B
     [,1] [,2]
[1,]    2    5
[2,]    3    6
[3,]    4    7

> A %*% B
     [,1] [,2]
[1,]   20   38
[2,]   47   92
```

特殊地、可以使用`crossprod(A,B)`函数来计算`t(A) %*% B`,使用`tcrossprod(A,B)`函数来计算`A %*% t(B)`。


<br>

<mark>矩阵的范数与矩阵的距离

范数（Norm）是数学中用于测量向量或矩阵的“长度”或“大小”的一种函数。范数在各种数学领域中都有应用，尤其是在线性代数、解析学和优化理论中。在矩阵中的应用如下：![alt text](ae05efbf3c9ad4a06d6539a7f372a03.png)
<br>


dist函数在R语言中用于计算矩阵或数据框中行与行之间的距离。它生成一个距离矩阵，表示每对行之间的距离。这个函数特别适用于聚类分析或其他需要计算多维数据点之间距离的统计方法。在矩阵中，每行可以看作一个观测点，每列作为不同的指标或者变量作为该观测点的属性。
```R
#计算向量或矩阵中的xx距离
dist(x, method = "euclidean", diag = FALSE, upper = FALSE, p = 2)

#method参数可以设置为多种类型的距离计算方法，默认为欧几里得距离
```

<br>

欧几里得距离在矩阵中的计算方法：
![alt text](5326cad91aaa589c5ecdf4dcaa521d6.png)

示例：
```R
A <- matrix(c(4,2,6,1,5,8,3,9,3,2,10,7),nrow = 4)
> A
     [,1] [,2] [,3]
[1,]    4    5    3
[2,]    2    8    2
[3,]    6    3   10
[4,]    1    9    7

> as.matrix(dist(A))  ##计算矩阵A的欧几里得距离
         1         2         3        4
1 0.000000  3.741657  7.549834 6.403124
2 3.741657  0.000000 10.246951 5.196152
3 7.549834 10.246951  0.000000 8.366600
4 6.403124  5.196152  8.366600 0.000000
```
<br>


字符串的编辑距离：  
`adist` 函数是 R 中用于计算两个字符串之间的编辑距离`（edit distance）`的函数。编辑距离，也被称为` Levenshtein `距离，是指将一个字符串转换成另一个字符串所需的最小操作次数。操作可以包括插入、删除或替换字符：
```R
# x一般为一个向量，最后返回的结果为矩阵
adist(x, y = NULL, costs = NULL, counts = FALSE, ...) 
```

比如：
```R
a <- c("hina","hn","nanhe","boy")
> names(a) <- a
> a
   hina      hn   nanhe     boy
 "hina"    "hn" "nanhe"   "boy"

> adist(a)  #计算a向量的字符编辑距离矩阵（对称）
      hina hn nanhe boy
hina     0  2     4   4
hn       2  0     4   3
nanhe    4  4     0   5
boy      4  3     5   0
```

进而，我们可以根据距离矩阵进行一个简单的聚类分析：
```R
#使用平均值进行聚类分析
h <- hclust(as.dist(a), method = "average")
plot(h)

#设定聚类的cluster数量
cutree(h,n)    #n为实际需要的cluster数量
```
聚类的结果如下：
![alt text](image-1.png)

<br>

计算矩阵的特征值：
可以使用`eigen()`函数计算矩阵的特征值和特征向量，比如：
```R
 a <- rbind(c(2,3,1),c(4,2,5),c(1,5,6))
> eigen(a)
eigen() decomposition
$values
[1] 10.359631 -2.691128  2.331497

$vectors
           [,1]       [,2]       [,3]
[1,] -0.3017316  0.4262455 -0.7586164
[2,] -0.5915655 -0.8044409 -0.2799374
[3,] -0.7476686  0.4137506  0.5883334
```

其他的矩阵应用：
1. QR decomposition（QR分解）
2. SVD decomposition（SVD分解）
3. 与矩阵相关的R包（适用于稀疏矩阵）


